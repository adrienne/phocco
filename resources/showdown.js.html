<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="content-type" content="text/html;charset=utf-8">
		<title>showdown.js</title>
		<meta name="viewport" content="width=device-width,initial-scale=1">
		<link href="http://alexgorbatchev.com/pub/sh/current/styles/shThemeDefault.css" rel="stylesheet" type="text/css" />
		<link rel="stylesheet" href="http://markhuot.github.com/phocco/resources/phocco.css">
	</head>
	<body>
		<div id="container">
				<div id="jump_to">
		<a id="jump_handle" href="#">Jump&nbsp;To&hellip;</a>
		<div id="jump_wrapper">
			<div id="jump_page">
									<a class="source" href="../phocco.php.html">
						phocco.php					</a>
									<a class="source" href="phocco.css.html">
						resources/phocco.css					</a>
									<a class="source" href="showdown.js.html">
						resources/showdown.js					</a>
							</div>
		</div>
	</div>
			<table cellspacing=0 cellpadding=0>
	<thead>
		<tr>
			<th class=docs><h1>showdown.js</h1></th>
			<th class=code></th>
		</tr>
	</thead>
	<tbody>

					<tr id="section-'0'">
				<td class="docs">
					<div class="pilwrap">
						<a class="pilcrow" href="#section-0">&#182;
						</a>
					</div>
<div class="doc">

 showdown.js -- A javascript port of Markdown.

 Copyright (c) 2007 John Fraser.

 Original Markdown Copyright (c) 2004-2005 John Gruber
   <http://daringfireball.net/projects/markdown/>

 Redistributable under a BSD-style open source license.
 See license.txt for more information.

 The full source distribution is at:

				A A L
				T C A
				T K B

   <http://www.attacklab.net/>
</div>
				</td>
				<td class="code">
									</td>
			</tr>
					<tr id="section-'1'">
				<td class="docs">
					<div class="pilwrap">
						<a class="pilcrow" href="#section-1">&#182;
						</a>
					</div>
<div class="doc">

 Wherever possible, Showdown is a straight, line-by-line port
 of the Perl version of Markdown.

 This is not a normal parser design; it's basically just a
 series of string substitutions.  It's hard to read and
 maintain this way,  but keeping Showdown close to the original
 design makes it easier to port new features.

 More importantly, Showdown behaves like markdown.pl in most
 edge cases.  So web applications can do client-side preview
 in Javascript, and then build identical HTML on the server.

 This port needs the new RegExp functionality of ECMA 262,
 3rd Edition (i.e. Javascript 1.5).  Most modern web browsers
 should do fine.  Even with the new regular expression features,
 We do a lot of work to emulate Perl's regex functionality.
 The tricky changes in this file mostly have the "attacklab:"
 label.  Major or self-explanatory changes don't.

 Smart diff tools like Araxis Merge will be able to match up
 this file with markdown.pl in a useful way.  A little tweaking
 helps: in a copy of markdown.pl, replace "#" with "//" and
 replace "$text" with "text".  Be sure to ignore whitespace
 and line endings.
</div>
				</td>
				<td class="code">
									</td>
			</tr>
					<tr id="section-'2'">
				<td class="docs">
					<div class="pilwrap">
						<a class="pilcrow" href="#section-2">&#182;
						</a>
					</div>
<div class="doc">

 Showdown usage:

   var text = "Markdown *rocks*.";

   var converter = new Showdown.converter();
   var html = converter.makeHtml(text);

   alert(html);

 Note: move the sample code to the bottom of this
 file before uncommenting it.
</div>
				</td>
				<td class="code">
									</td>
			</tr>
					<tr id="section-'3'">
				<td class="docs">
					<div class="pilwrap">
						<a class="pilcrow" href="#section-3">&#182;
						</a>
					</div>
<div class="doc">

 Showdown namespace
</div>
				</td>
				<td class="code">
										<div class="highlight">
<pre class="brush: js">
var Showdown = {};
</pre>
					</div>
									</td>
			</tr>
					<tr id="section-'4'">
				<td class="docs">
					<div class="pilwrap">
						<a class="pilcrow" href="#section-4">&#182;
						</a>
					</div>
<div class="doc">

 converter

 Wraps all "globals" so that the only thing
 exposed is makeHtml().
</div>
				</td>
				<td class="code">
										<div class="highlight">
<pre class="brush: js">
Showdown.converter = function() {
</pre>
					</div>
									</td>
			</tr>
					<tr id="section-'5'">
				<td class="docs">
					<div class="pilwrap">
						<a class="pilcrow" href="#section-5">&#182;
						</a>
					</div>
<div class="doc">

 Globals:
</div>
				</td>
				<td class="code">
									</td>
			</tr>
					<tr id="section-'6'">
				<td class="docs">
					<div class="pilwrap">
						<a class="pilcrow" href="#section-6">&#182;
						</a>
					</div>
<div class="doc">
 Global hashes, used by various utility routines</div>
				</td>
				<td class="code">
										<div class="highlight">
<pre class="brush: js">
var g_urls;
var g_titles;
var g_html_blocks;
</pre>
					</div>
									</td>
			</tr>
					<tr id="section-'7'">
				<td class="docs">
					<div class="pilwrap">
						<a class="pilcrow" href="#section-7">&#182;
						</a>
					</div>
<div class="doc">
 Used to track when we're inside an ordered or unordered list
 (see _ProcessListItems() for details):</div>
				</td>
				<td class="code">
										<div class="highlight">
<pre class="brush: js">
var g_list_level = 0;


this.makeHtml = function(text) {</pre>
					</div>
									</td>
			</tr>
					<tr id="section-'8'">
				<td class="docs">
					<div class="pilwrap">
						<a class="pilcrow" href="#section-8">&#182;
						</a>
					</div>
<div class="doc">

 Main function. The order in which other subs are called here is
 essential. Link and image substitutions need to happen before
 _EscapeSpecialCharsWithinTagAttributes(), so that any *'s or _'s in the <a>
 and <img> tags get encoded.
</div>
				</td>
				<td class="code">
									</td>
			</tr>
					<tr id="section-'9'">
				<td class="docs">
					<div class="pilwrap">
						<a class="pilcrow" href="#section-9">&#182;
						</a>
					</div>
<div class="doc">
 Clear the global hashes. If we don't clear these, you get conflicts
 from other articles when generating a page which contains more than
 one article (e.g. an index page that shows the N most recent
 articles):</div>
				</td>
				<td class="code">
										<div class="highlight">
<pre class="brush: js">
	g_urls = new Array();
	g_titles = new Array();
	g_html_blocks = new Array();
</pre>
					</div>
									</td>
			</tr>
					<tr id="section-'10'">
				<td class="docs">
					<div class="pilwrap">
						<a class="pilcrow" href="#section-10">&#182;
						</a>
					</div>
<div class="doc">
 attacklab: Replace ~ with ~T
 This lets us use tilde as an escape char to avoid md5 hashes
 The choice of character is arbitray; anything that isn't
 magic in Markdown will work.</div>
				</td>
				<td class="code">
										<div class="highlight">
<pre class="brush: js">
	text = text.replace(/~/g,&quot;~T&quot;);
</pre>
					</div>
									</td>
			</tr>
					<tr id="section-'11'">
				<td class="docs">
					<div class="pilwrap">
						<a class="pilcrow" href="#section-11">&#182;
						</a>
					</div>
<div class="doc">
 attacklab: Replace $ with ~D
 RegExp interprets $ as a special character
 when it's in a replacement string</div>
				</td>
				<td class="code">
										<div class="highlight">
<pre class="brush: js">
	text = text.replace(/\$/g,&quot;~D&quot;);
</pre>
					</div>
									</td>
			</tr>
					<tr id="section-'12'">
				<td class="docs">
					<div class="pilwrap">
						<a class="pilcrow" href="#section-12">&#182;
						</a>
					</div>
<div class="doc">
 Standardize line endings</div>
				</td>
				<td class="code">
										<div class="highlight">
<pre class="brush: js">
	text = text.replace(/\r\n/g,&quot;\n&quot;); // DOS to Unix
	text = text.replace(/\r/g,&quot;\n&quot;); // Mac to Unix
</pre>
					</div>
									</td>
			</tr>
					<tr id="section-'13'">
				<td class="docs">
					<div class="pilwrap">
						<a class="pilcrow" href="#section-13">&#182;
						</a>
					</div>
<div class="doc">
 Make sure text begins and ends with a couple of newlines:</div>
				</td>
				<td class="code">
										<div class="highlight">
<pre class="brush: js">
	text = &quot;\n\n&quot; + text + &quot;\n\n&quot;;
</pre>
					</div>
									</td>
			</tr>
					<tr id="section-'14'">
				<td class="docs">
					<div class="pilwrap">
						<a class="pilcrow" href="#section-14">&#182;
						</a>
					</div>
<div class="doc">
 Convert all tabs to spaces.</div>
				</td>
				<td class="code">
										<div class="highlight">
<pre class="brush: js">
	text = _Detab(text);
</pre>
					</div>
									</td>
			</tr>
					<tr id="section-'15'">
				<td class="docs">
					<div class="pilwrap">
						<a class="pilcrow" href="#section-15">&#182;
						</a>
					</div>
<div class="doc">
 Strip any lines consisting only of spaces and tabs.
 This makes subsequent regexen easier to write, because we can
 match consecutive blank lines with /\n+/ instead of something
 contorted like /[ \t]*\n+/ .</div>
				</td>
				<td class="code">
										<div class="highlight">
<pre class="brush: js">
	text = text.replace(/^[ \t]+$/mg,&quot;&quot;);
</pre>
					</div>
									</td>
			</tr>
					<tr id="section-'16'">
				<td class="docs">
					<div class="pilwrap">
						<a class="pilcrow" href="#section-16">&#182;
						</a>
					</div>
<div class="doc">
 Turn block-level HTML blocks into hash entries</div>
				</td>
				<td class="code">
										<div class="highlight">
<pre class="brush: js">
	text = _HashHTMLBlocks(text);
</pre>
					</div>
									</td>
			</tr>
					<tr id="section-'17'">
				<td class="docs">
					<div class="pilwrap">
						<a class="pilcrow" href="#section-17">&#182;
						</a>
					</div>
<div class="doc">
 Strip link definitions, store in hashes.</div>
				</td>
				<td class="code">
										<div class="highlight">
<pre class="brush: js">
	text = _StripLinkDefinitions(text);

	text = _RunBlockGamut(text);

	text = _UnescapeSpecialChars(text);
</pre>
					</div>
									</td>
			</tr>
					<tr id="section-'18'">
				<td class="docs">
					<div class="pilwrap">
						<a class="pilcrow" href="#section-18">&#182;
						</a>
					</div>
<div class="doc">
 attacklab: Restore dollar signs</div>
				</td>
				<td class="code">
										<div class="highlight">
<pre class="brush: js">
	text = text.replace(/~D/g,&quot;$$&quot;);
</pre>
					</div>
									</td>
			</tr>
					<tr id="section-'19'">
				<td class="docs">
					<div class="pilwrap">
						<a class="pilcrow" href="#section-19">&#182;
						</a>
					</div>
<div class="doc">
 attacklab: Restore tildes</div>
				</td>
				<td class="code">
										<div class="highlight">
<pre class="brush: js">
	text = text.replace(/~T/g,&quot;~&quot;);

	return text;
}


var _StripLinkDefinitions = function(text) {</pre>
					</div>
									</td>
			</tr>
					<tr id="section-'20'">
				<td class="docs">
					<div class="pilwrap">
						<a class="pilcrow" href="#section-20">&#182;
						</a>
					</div>
<div class="doc">

 Strips link definitions from text, stores the URLs and titles in
 hash references.
</div>
				</td>
				<td class="code">
									</td>
			</tr>
					<tr id="section-'21'">
				<td class="docs">
					<div class="pilwrap">
						<a class="pilcrow" href="#section-21">&#182;
						</a>
					</div>
<div class="doc">
 Link defs are in the form: ^[id]: url "optional title"</div>
				</td>
				<td class="code">
										<div class="highlight">
<pre class="brush: js">

	/*
		var text = text.replace(/
				^[ ]{0,3}\[(.+)\]:  // id = $1  attacklab: g_tab_width - 1
				  [ \t]*
				  \n?				// maybe *one* newline
				  [ \t]*
				&lt;?(\S+?)&gt;?			// url = $2
				  [ \t]*
				  \n?				// maybe one newline
				  [ \t]*
				(?:
				  (\n*)				// any lines skipped = $3 attacklab: lookbehind removed
				  [&quot;(]
				  (.+?)				// title = $4
				  [&quot;)]
				  [ \t]*
				)?					// title is optional
				(?:\n+|$)
			  /gm,
			  function(){...});
	*/
	var text = text.replace(/^[ ]{0,3}\[(.+)\]:[ \t]*\n?[ \t]*&lt;?(\S+?)&gt;?[ \t]*\n?[ \t]*(?:(\n*)[&quot;(](.+?)[&quot;)][ \t]*)?(?:\n+|\Z)/gm,
		function (wholeMatch,m1,m2,m3,m4) {
			m1 = m1.toLowerCase();
			g_urls[m1] = _EncodeAmpsAndAngles(m2);  // Link IDs are case-insensitive
			if (m3) {</pre>
					</div>
									</td>
			</tr>
					<tr id="section-'22'">
				<td class="docs">
					<div class="pilwrap">
						<a class="pilcrow" href="#section-22">&#182;
						</a>
					</div>
<div class="doc">
 Oops, found blank lines, so it's not a title.
 Put back the parenthetical statement we stole.</div>
				</td>
				<td class="code">
										<div class="highlight">
<pre class="brush: js">
				return m3+m4;
			} else if (m4) {
				g_titles[m1] = m4.replace(/&quot;/g,&quot;&amp;quot;&quot;);
			}
			</pre>
					</div>
									</td>
			</tr>
					<tr id="section-'23'">
				<td class="docs">
					<div class="pilwrap">
						<a class="pilcrow" href="#section-23">&#182;
						</a>
					</div>
<div class="doc">
 Completely remove the definition from the text</div>
				</td>
				<td class="code">
										<div class="highlight">
<pre class="brush: js">
			return &quot;&quot;;
		}
	);

	return text;
}


var _HashHTMLBlocks = function(text) {</pre>
					</div>
									</td>
			</tr>
					<tr id="section-'24'">
				<td class="docs">
					<div class="pilwrap">
						<a class="pilcrow" href="#section-24">&#182;
						</a>
					</div>
<div class="doc">
 attacklab: Double up blank lines to reduce lookaround</div>
				</td>
				<td class="code">
										<div class="highlight">
<pre class="brush: js">
	text = text.replace(/\n/g,&quot;\n\n&quot;);
</pre>
					</div>
									</td>
			</tr>
					<tr id="section-'25'">
				<td class="docs">
					<div class="pilwrap">
						<a class="pilcrow" href="#section-25">&#182;
						</a>
					</div>
<div class="doc">
 Hashify HTML blocks:
 We only want to do this for block-level HTML tags, such as headers,
 lists, and tables. That's because we still want to wrap <p>s around
 "paragraphs" that are wrapped in non-block-level tags, such as anchors,
 phrase emphasis, and spans. The list of tags we're looking for is
 hard-coded:</div>
				</td>
				<td class="code">
										<div class="highlight">
<pre class="brush: js">
	var block_tags_a = &quot;p|div|h[1-6]|blockquote|pre|table|dl|ol|ul|script|noscript|form|fieldset|iframe|math|ins|del&quot;
	var block_tags_b = &quot;p|div|h[1-6]|blockquote|pre|table|dl|ol|ul|script|noscript|form|fieldset|iframe|math&quot;
</pre>
					</div>
									</td>
			</tr>
					<tr id="section-'26'">
				<td class="docs">
					<div class="pilwrap">
						<a class="pilcrow" href="#section-26">&#182;
						</a>
					</div>
<div class="doc">
 First, look for nested blocks, e.g.:
   <div>
     <div>
     tags for inner block must be indented.
     </div>
   </div>

 The outermost tags must start at the left margin for this to match, and
 the inner nested divs must be indented.
 We need to do this before the next, more liberal match, because the next
 match will start at the first `<div>` and stop at the first `</div>`.</div>
				</td>
				<td class="code">
									</td>
			</tr>
					<tr id="section-'27'">
				<td class="docs">
					<div class="pilwrap">
						<a class="pilcrow" href="#section-27">&#182;
						</a>
					</div>
<div class="doc">
 attacklab: This regex can be expensive when it fails.</div>
				</td>
				<td class="code">
										<div class="highlight">
<pre class="brush: js">
	/*
		var text = text.replace(/
		(						// save in $1
			^					// start of line  (with /m)
			&lt;($block_tags_a)	// start tag = $2
			\b					// word break</pre>
					</div>
									</td>
			</tr>
					<tr id="section-'28'">
				<td class="docs">
					<div class="pilwrap">
						<a class="pilcrow" href="#section-28">&#182;
						</a>
					</div>
<div class="doc">
 attacklab: hack around khtml/pcre bug...</div>
				</td>
				<td class="code">
										<div class="highlight">
<pre class="brush: js">
			[^\r]*?\n			// any number of lines, minimally matching
			&lt;/\2&gt;				// the matching end tag
			[ \t]*				// trailing spaces/tabs
			(?=\n+)				// followed by a newline
		)						// attacklab: there are sentinel newlines at end of document
		/gm,function(){...}};
	*/
	text = text.replace(/^(&lt;(p|div|h[1-6]|blockquote|pre|table|dl|ol|ul|script|noscript|form|fieldset|iframe|math|ins|del)\b[^\r]*?\n&lt;\/\2&gt;[ \t]*(?=\n+))/gm,hashElement);
</pre>
					</div>
									</td>
			</tr>
					<tr id="section-'29'">
				<td class="docs">
					<div class="pilwrap">
						<a class="pilcrow" href="#section-29">&#182;
						</a>
					</div>
<div class="doc">

 Now match more liberally, simply from `\n<tag>` to `</tag>\n`
</div>
				</td>
				<td class="code">
										<div class="highlight">
<pre class="brush: js">

	/*
		var text = text.replace(/
		(						// save in $1
			^					// start of line  (with /m)
			&lt;($block_tags_b)	// start tag = $2
			\b					// word break</pre>
					</div>
									</td>
			</tr>
					<tr id="section-'30'">
				<td class="docs">
					<div class="pilwrap">
						<a class="pilcrow" href="#section-30">&#182;
						</a>
					</div>
<div class="doc">
 attacklab: hack around khtml/pcre bug...</div>
				</td>
				<td class="code">
										<div class="highlight">
<pre class="brush: js">
			[^\r]*?				// any number of lines, minimally matching
			.*&lt;/\2&gt;				// the matching end tag
			[ \t]*				// trailing spaces/tabs
			(?=\n+)				// followed by a newline
		)						// attacklab: there are sentinel newlines at end of document
		/gm,function(){...}};
	*/
	text = text.replace(/^(&lt;(p|div|h[1-6]|blockquote|pre|table|dl|ol|ul|script|noscript|form|fieldset|iframe|math)\b[^\r]*?.*&lt;\/\2&gt;[ \t]*(?=\n+)\n)/gm,hashElement);
</pre>
					</div>
									</td>
			</tr>
					<tr id="section-'31'">
				<td class="docs">
					<div class="pilwrap">
						<a class="pilcrow" href="#section-31">&#182;
						</a>
					</div>
<div class="doc">
 Special case just for <hr />. It was easier to make a special case than
 to make the other regex more complicated.  </div>
				</td>
				<td class="code">
										<div class="highlight">
<pre class="brush: js">

	/*
		text = text.replace(/
		(						// save in $1
			\n\n				// Starting after a blank line
			[ ]{0,3}
			(&lt;(hr)				// start tag = $2
			\b					// word break
			([^&lt;&gt;])*?			// 
			\/?&gt;)				// the matching end tag
			[ \t]*
			(?=\n{2,})			// followed by a blank line
		)
		/g,hashElement);
	*/
	text = text.replace(/(\n[ ]{0,3}(&lt;(hr)\b([^&lt;&gt;])*?\/?&gt;)[ \t]*(?=\n{2,}))/g,hashElement);
</pre>
					</div>
									</td>
			</tr>
					<tr id="section-'32'">
				<td class="docs">
					<div class="pilwrap">
						<a class="pilcrow" href="#section-32">&#182;
						</a>
					</div>
<div class="doc">
 Special case for standalone HTML comments:</div>
				</td>
				<td class="code">
										<div class="highlight">
<pre class="brush: js">

	/*
		text = text.replace(/
		(						// save in $1
			\n\n				// Starting after a blank line
			[ ]{0,3}			// attacklab: g_tab_width - 1
			&lt;!
			(--[^\r]*?--\s*)+
			&gt;
			[ \t]*
			(?=\n{2,})			// followed by a blank line
		)
		/g,hashElement);
	*/
	text = text.replace(/(\n\n[ ]{0,3}&lt;!(--[^\r]*?--\s*)+&gt;[ \t]*(?=\n{2,}))/g,hashElement);
</pre>
					</div>
									</td>
			</tr>
					<tr id="section-'33'">
				<td class="docs">
					<div class="pilwrap">
						<a class="pilcrow" href="#section-33">&#182;
						</a>
					</div>
<div class="doc">
 PHP and ASP-style processor instructions (<?...?> and <%...%>)</div>
				</td>
				<td class="code">
										<div class="highlight">
<pre class="brush: js">

	/*
		text = text.replace(/
		(?:
			\n\n				// Starting after a blank line
		)
		(						// save in $1
			[ ]{0,3}			// attacklab: g_tab_width - 1
			(?:
				&lt;([?%])			// $2
				[^\r]*?
				\2&gt;
			)
			[ \t]*
			(?=\n{2,})			// followed by a blank line
		)
		/g,hashElement);
	*/
	text = text.replace(/(?:\n\n)([ ]{0,3}(?:&lt;([?%])[^\r]*?\2&gt;)[ \t]*(?=\n{2,}))/g,hashElement);
</pre>
					</div>
									</td>
			</tr>
					<tr id="section-'34'">
				<td class="docs">
					<div class="pilwrap">
						<a class="pilcrow" href="#section-34">&#182;
						</a>
					</div>
<div class="doc">
 attacklab: Undo double lines (see comment at top of this function)</div>
				</td>
				<td class="code">
										<div class="highlight">
<pre class="brush: js">
	text = text.replace(/\n\n/g,&quot;\n&quot;);
	return text;
}

var hashElement = function(wholeMatch,m1) {
	var blockText = m1;
</pre>
					</div>
									</td>
			</tr>
					<tr id="section-'35'">
				<td class="docs">
					<div class="pilwrap">
						<a class="pilcrow" href="#section-35">&#182;
						</a>
					</div>
<div class="doc">
 Undo double lines</div>
				</td>
				<td class="code">
										<div class="highlight">
<pre class="brush: js">
	blockText = blockText.replace(/\n\n/g,&quot;\n&quot;);
	blockText = blockText.replace(/^\n/,&quot;&quot;);
	</pre>
					</div>
									</td>
			</tr>
					<tr id="section-'36'">
				<td class="docs">
					<div class="pilwrap">
						<a class="pilcrow" href="#section-36">&#182;
						</a>
					</div>
<div class="doc">
 strip trailing blank lines</div>
				</td>
				<td class="code">
										<div class="highlight">
<pre class="brush: js">
	blockText = blockText.replace(/\n+$/g,&quot;&quot;);
	</pre>
					</div>
									</td>
			</tr>
					<tr id="section-'37'">
				<td class="docs">
					<div class="pilwrap">
						<a class="pilcrow" href="#section-37">&#182;
						</a>
					</div>
<div class="doc">
 Replace the element text with a marker ("~KxK" where x is its key)</div>
				</td>
				<td class="code">
										<div class="highlight">
<pre class="brush: js">
	blockText = &quot;\n\n~K&quot; + (g_html_blocks.push(blockText)-1) + &quot;K\n\n&quot;;
	
	return blockText;
};

var _RunBlockGamut = function(text) {</pre>
					</div>
									</td>
			</tr>
					<tr id="section-'38'">
				<td class="docs">
					<div class="pilwrap">
						<a class="pilcrow" href="#section-38">&#182;
						</a>
					</div>
<div class="doc">

 These are all the transformations that form block-level
 tags like paragraphs, headers, and list items.
</div>
				</td>
				<td class="code">
										<div class="highlight">
<pre class="brush: js">
	text = _DoHeaders(text);
</pre>
					</div>
									</td>
			</tr>
					<tr id="section-'39'">
				<td class="docs">
					<div class="pilwrap">
						<a class="pilcrow" href="#section-39">&#182;
						</a>
					</div>
<div class="doc">
 Do Horizontal Rules:</div>
				</td>
				<td class="code">
										<div class="highlight">
<pre class="brush: js">
	var key = hashBlock(&quot;&lt;hr /&gt;&quot;);
	text = text.replace(/^[ ]{0,2}([ ]?\*[ ]?){3,}[ \t]*$/gm,key);
	text = text.replace(/^[ ]{0,2}([ ]?\-[ ]?){3,}[ \t]*$/gm,key);
	text = text.replace(/^[ ]{0,2}([ ]?\_[ ]?){3,}[ \t]*$/gm,key);

	text = _DoLists(text);
	text = _DoCodeBlocks(text);
	text = _DoBlockQuotes(text);
</pre>
					</div>
									</td>
			</tr>
					<tr id="section-'40'">
				<td class="docs">
					<div class="pilwrap">
						<a class="pilcrow" href="#section-40">&#182;
						</a>
					</div>
<div class="doc">
 We already ran _HashHTMLBlocks() before, in Markdown(), but that
 was to escape raw HTML in the original Markdown source. This time,
 we're escaping the markup we've just created, so that we don't wrap
 <p> tags around block-level tags.</div>
				</td>
				<td class="code">
										<div class="highlight">
<pre class="brush: js">
	text = _HashHTMLBlocks(text);
	text = _FormParagraphs(text);

	return text;
}


var _RunSpanGamut = function(text) {</pre>
					</div>
									</td>
			</tr>
					<tr id="section-'41'">
				<td class="docs">
					<div class="pilwrap">
						<a class="pilcrow" href="#section-41">&#182;
						</a>
					</div>
<div class="doc">

 These are all the transformations that occur *within* block-level
 tags like paragraphs, headers, and list items.
</div>
				</td>
				<td class="code">
										<div class="highlight">
<pre class="brush: js">

	text = _DoCodeSpans(text);
	text = _EscapeSpecialCharsWithinTagAttributes(text);
	text = _EncodeBackslashEscapes(text);
</pre>
					</div>
									</td>
			</tr>
					<tr id="section-'42'">
				<td class="docs">
					<div class="pilwrap">
						<a class="pilcrow" href="#section-42">&#182;
						</a>
					</div>
<div class="doc">
 Process anchor and image tags. Images must come first,
 because ![foo][f] looks like an anchor.</div>
				</td>
				<td class="code">
										<div class="highlight">
<pre class="brush: js">
	text = _DoImages(text);
	text = _DoAnchors(text);
</pre>
					</div>
									</td>
			</tr>
					<tr id="section-'43'">
				<td class="docs">
					<div class="pilwrap">
						<a class="pilcrow" href="#section-43">&#182;
						</a>
					</div>
<div class="doc">
 Make links out of things like `<http://example.com/>`
 Must come after _DoAnchors(), because you can use < and >
 delimiters in inline links like [this](<url>).</div>
				</td>
				<td class="code">
										<div class="highlight">
<pre class="brush: js">
	text = _DoAutoLinks(text);
	text = _EncodeAmpsAndAngles(text);
	text = _DoItalicsAndBold(text);
</pre>
					</div>
									</td>
			</tr>
					<tr id="section-'44'">
				<td class="docs">
					<div class="pilwrap">
						<a class="pilcrow" href="#section-44">&#182;
						</a>
					</div>
<div class="doc">
 Do hard breaks:</div>
				</td>
				<td class="code">
										<div class="highlight">
<pre class="brush: js">
	text = text.replace(/  +\n/g,&quot; &lt;br /&gt;\n&quot;);

	return text;
}

var _EscapeSpecialCharsWithinTagAttributes = function(text) {</pre>
					</div>
									</td>
			</tr>
					<tr id="section-'45'">
				<td class="docs">
					<div class="pilwrap">
						<a class="pilcrow" href="#section-45">&#182;
						</a>
					</div>
<div class="doc">

 Within tags -- meaning between < and > -- encode [\ ` * _] so they
 don't conflict with their use in Markdown for code, italics and strong.
</div>
				</td>
				<td class="code">
									</td>
			</tr>
					<tr id="section-'46'">
				<td class="docs">
					<div class="pilwrap">
						<a class="pilcrow" href="#section-46">&#182;
						</a>
					</div>
<div class="doc">
 Build a regex to find HTML tags and comments.  See Friedl's 
 "Mastering Regular Expressions", 2nd Ed., pp. 200-201.</div>
				</td>
				<td class="code">
										<div class="highlight">
<pre class="brush: js">
	var regex = /(&lt;[a-z\/!$](&quot;[^&quot;]*&quot;|'[^']*'|[^'&quot;&gt;])*&gt;|&lt;!(--.*?--\s*)+&gt;)/gi;

	text = text.replace(regex, function(wholeMatch) {
		var tag = wholeMatch.replace(/(.)&lt;\/?code&gt;(?=.)/g,&quot;$1`&quot;);
		tag = escapeCharacters(tag,&quot;\\`*_&quot;);
		return tag;
	});

	return text;
}

var _DoAnchors = function(text) {</pre>
					</div>
									</td>
			</tr>
					<tr id="section-'47'">
				<td class="docs">
					<div class="pilwrap">
						<a class="pilcrow" href="#section-47">&#182;
						</a>
					</div>
<div class="doc">

 Turn Markdown link shortcuts into XHTML <a> tags.


 First, handle reference-style links: [link text] [id]
</div>
				</td>
				<td class="code">
										<div class="highlight">
<pre class="brush: js">

	/*
		text = text.replace(/
		(							// wrap whole match in $1
			\[
			(
				(?:
					\[[^\]]*\]		// allow brackets nested one level
					|
					[^\[]			// or anything else
				)*
			)
			\]

			[ ]?					// one optional space
			(?:\n[ ]*)?				// one optional newline followed by spaces

			\[
			(.*?)					// id = $3
			\]
		)()()()()					// pad remaining backreferences
		/g,_DoAnchors_callback);
	*/
	text = text.replace(/(\[((?:\[[^\]]*\]|[^\[\]])*)\][ ]?(?:\n[ ]*)?\[(.*?)\])()()()()/g,writeAnchorTag);
</pre>
					</div>
									</td>
			</tr>
					<tr id="section-'48'">
				<td class="docs">
					<div class="pilwrap">
						<a class="pilcrow" href="#section-48">&#182;
						</a>
					</div>
<div class="doc">

 Next, inline-style links: [link text](url "optional title")
</div>
				</td>
				<td class="code">
										<div class="highlight">
<pre class="brush: js">

	/*
		text = text.replace(/
			(						// wrap whole match in $1
				\[
				(
					(?:
						\[[^\]]*\]	// allow brackets nested one level
					|
					[^\[\]]			// or anything else
				)
			)
			\]
			\(						// literal paren
			[ \t]*
			()						// no id, so leave $3 empty
			&lt;?(.*?)&gt;?				// href = $4
			[ \t]*
			(						// $5
				(['&quot;])				// quote char = $6
				(.*?)				// Title = $7
				\6					// matching quote
				[ \t]*				// ignore any spaces/tabs between closing quote and )
			)?						// title is optional
			\)
		)
		/g,writeAnchorTag);
	*/
	text = text.replace(/(\[((?:\[[^\]]*\]|[^\[\]])*)\]\([ \t]*()&lt;?(.*?)&gt;?[ \t]*((['&quot;])(.*?)\6[ \t]*)?\))/g,writeAnchorTag);
</pre>
					</div>
									</td>
			</tr>
					<tr id="section-'49'">
				<td class="docs">
					<div class="pilwrap">
						<a class="pilcrow" href="#section-49">&#182;
						</a>
					</div>
<div class="doc">

 Last, handle reference-style shortcuts: [link text]
 These must come last in case you've also got [link test][1]
 or [link test](/foo)
</div>
				</td>
				<td class="code">
										<div class="highlight">
<pre class="brush: js">

	/*
		text = text.replace(/
		(		 					// wrap whole match in $1
			\[
			([^\[\]]+)				// link text = $2; can't contain '[' or ']'
			\]
		)()()()()()					// pad rest of backreferences
		/g, writeAnchorTag);
	*/
	text = text.replace(/(\[([^\[\]]+)\])()()()()()/g, writeAnchorTag);

	return text;
}

var writeAnchorTag = function(wholeMatch,m1,m2,m3,m4,m5,m6,m7) {
	if (m7 == undefined) m7 = &quot;&quot;;
	var whole_match = m1;
	var link_text   = m2;
	var link_id	 = m3.toLowerCase();
	var url		= m4;
	var title	= m7;
	
	if (url == &quot;&quot;) {
		if (link_id == &quot;&quot;) {</pre>
					</div>
									</td>
			</tr>
					<tr id="section-'50'">
				<td class="docs">
					<div class="pilwrap">
						<a class="pilcrow" href="#section-50">&#182;
						</a>
					</div>
<div class="doc">
 lower-case and turn embedded newlines into spaces</div>
				</td>
				<td class="code">
										<div class="highlight">
<pre class="brush: js">
			link_id = link_text.toLowerCase().replace(/ ?\n/g,&quot; &quot;);
		}
		url = &quot;#&quot;+link_id;
		
		if (g_urls[link_id] != undefined) {
			url = g_urls[link_id];
			if (g_titles[link_id] != undefined) {
				title = g_titles[link_id];
			}
		}
		else {
			if (whole_match.search(/\(\s*\)$/m)&gt;-1) {</pre>
					</div>
									</td>
			</tr>
					<tr id="section-'51'">
				<td class="docs">
					<div class="pilwrap">
						<a class="pilcrow" href="#section-51">&#182;
						</a>
					</div>
<div class="doc">
 Special case for explicit empty url</div>
				</td>
				<td class="code">
										<div class="highlight">
<pre class="brush: js">
				url = &quot;&quot;;
			} else {
				return whole_match;
			}
		}
	}	
	
	url = escapeCharacters(url,&quot;*_&quot;);
	var result = &quot;&lt;a href=\&quot;&quot; + url + &quot;\&quot;&quot;;
	
	if (title != &quot;&quot;) {
		title = title.replace(/&quot;/g,&quot;&amp;quot;&quot;);
		title = escapeCharacters(title,&quot;*_&quot;);
		result +=  &quot; title=\&quot;&quot; + title + &quot;\&quot;&quot;;
	}
	
	result += &quot;&gt;&quot; + link_text + &quot;&lt;/a&gt;&quot;;
	
	return result;
}


var _DoImages = function(text) {</pre>
					</div>
									</td>
			</tr>
					<tr id="section-'52'">
				<td class="docs">
					<div class="pilwrap">
						<a class="pilcrow" href="#section-52">&#182;
						</a>
					</div>
<div class="doc">

 Turn Markdown image shortcuts into <img> tags.
</div>
				</td>
				<td class="code">
									</td>
			</tr>
					<tr id="section-'53'">
				<td class="docs">
					<div class="pilwrap">
						<a class="pilcrow" href="#section-53">&#182;
						</a>
					</div>
<div class="doc">

 First, handle reference-style labeled images: ![alt text][id]
</div>
				</td>
				<td class="code">
										<div class="highlight">
<pre class="brush: js">

	/*
		text = text.replace(/
		(						// wrap whole match in $1
			!\[
			(.*?)				// alt text = $2
			\]

			[ ]?				// one optional space
			(?:\n[ ]*)?			// one optional newline followed by spaces

			\[
			(.*?)				// id = $3
			\]
		)()()()()				// pad rest of backreferences
		/g,writeImageTag);
	*/
	text = text.replace(/(!\[(.*?)\][ ]?(?:\n[ ]*)?\[(.*?)\])()()()()/g,writeImageTag);
</pre>
					</div>
									</td>
			</tr>
					<tr id="section-'54'">
				<td class="docs">
					<div class="pilwrap">
						<a class="pilcrow" href="#section-54">&#182;
						</a>
					</div>
<div class="doc">

 Next, handle inline images:  ![alt text](url "optional title")
 Don't forget: encode * and _</div>
				</td>
				<td class="code">
										<div class="highlight">
<pre class="brush: js">

	/*
		text = text.replace(/
		(						// wrap whole match in $1
			!\[
			(.*?)				// alt text = $2
			\]
			\s?					// One optional whitespace character
			\(					// literal paren
			[ \t]*
			()					// no id, so leave $3 empty
			&lt;?(\S+?)&gt;?			// src url = $4
			[ \t]*
			(					// $5
				(['&quot;])			// quote char = $6
				(.*?)			// title = $7
				\6				// matching quote
				[ \t]*
			)?					// title is optional
		\)
		)
		/g,writeImageTag);
	*/
	text = text.replace(/(!\[(.*?)\]\s?\([ \t]*()&lt;?(\S+?)&gt;?[ \t]*((['&quot;])(.*?)\6[ \t]*)?\))/g,writeImageTag);

	return text;
}

var writeImageTag = function(wholeMatch,m1,m2,m3,m4,m5,m6,m7) {
	var whole_match = m1;
	var alt_text   = m2;
	var link_id	 = m3.toLowerCase();
	var url		= m4;
	var title	= m7;

	if (!title) title = &quot;&quot;;
	
	if (url == &quot;&quot;) {
		if (link_id == &quot;&quot;) {</pre>
					</div>
									</td>
			</tr>
					<tr id="section-'55'">
				<td class="docs">
					<div class="pilwrap">
						<a class="pilcrow" href="#section-55">&#182;
						</a>
					</div>
<div class="doc">
 lower-case and turn embedded newlines into spaces</div>
				</td>
				<td class="code">
										<div class="highlight">
<pre class="brush: js">
			link_id = alt_text.toLowerCase().replace(/ ?\n/g,&quot; &quot;);
		}
		url = &quot;#&quot;+link_id;
		
		if (g_urls[link_id] != undefined) {
			url = g_urls[link_id];
			if (g_titles[link_id] != undefined) {
				title = g_titles[link_id];
			}
		}
		else {
			return whole_match;
		}
	}	
	
	alt_text = alt_text.replace(/&quot;/g,&quot;&amp;quot;&quot;);
	url = escapeCharacters(url,&quot;*_&quot;);
	var result = &quot;&lt;img src=\&quot;&quot; + url + &quot;\&quot; alt=\&quot;&quot; + alt_text + &quot;\&quot;&quot;;
</pre>
					</div>
									</td>
			</tr>
					<tr id="section-'56'">
				<td class="docs">
					<div class="pilwrap">
						<a class="pilcrow" href="#section-56">&#182;
						</a>
					</div>
<div class="doc">
 attacklab: Markdown.pl adds empty title attributes to images.
 Replicate this bug.</div>
				</td>
				<td class="code">
									</td>
			</tr>
					<tr id="section-'57'">
				<td class="docs">
					<div class="pilwrap">
						<a class="pilcrow" href="#section-57">&#182;
						</a>
					</div>
<div class="doc">
if (title != "") {</div>
				</td>
				<td class="code">
										<div class="highlight">
<pre class="brush: js">
		title = title.replace(/&quot;/g,&quot;&amp;quot;&quot;);
		title = escapeCharacters(title,&quot;*_&quot;);
		result +=  &quot; title=\&quot;&quot; + title + &quot;\&quot;&quot;;</pre>
					</div>
									</td>
			</tr>
					<tr id="section-'58'">
				<td class="docs">
					<div class="pilwrap">
						<a class="pilcrow" href="#section-58">&#182;
						</a>
					</div>
<div class="doc">
}</div>
				</td>
				<td class="code">
										<div class="highlight">
<pre class="brush: js">
	
	result += &quot; /&gt;&quot;;
	
	return result;
}


var _DoHeaders = function(text) {
</pre>
					</div>
									</td>
			</tr>
					<tr id="section-'59'">
				<td class="docs">
					<div class="pilwrap">
						<a class="pilcrow" href="#section-59">&#182;
						</a>
					</div>
<div class="doc">
 Setext-style headers:
	Header 1
	========
  
	Header 2
	--------
</div>
				</td>
				<td class="code">
										<div class="highlight">
<pre class="brush: js">
	text = text.replace(/^(.+)[ \t]*\n=+[ \t]*\n+/gm,
		function(wholeMatch,m1){return hashBlock('&lt;h1 id=&quot;' + headerId(m1) + '&quot;&gt;' + _RunSpanGamut(m1) + &quot;&lt;/h1&gt;&quot;);});

	text = text.replace(/^(.+)[ \t]*\n-+[ \t]*\n+/gm,
		function(matchFound,m1){return hashBlock('&lt;h2 id=&quot;' + headerId(m1) + '&quot;&gt;' + _RunSpanGamut(m1) + &quot;&lt;/h2&gt;&quot;);});
</pre>
					</div>
									</td>
			</tr>
					<tr id="section-'60'">
				<td class="docs">
					<div class="pilwrap">
						<a class="pilcrow" href="#section-60">&#182;
						</a>
					</div>
<div class="doc">
 atx-style headers:
  # Header 1
  ## Header 2
  ## Header 2 with closing hashes ##
  ...
  ###### Header 6
</div>
				</td>
				<td class="code">
										<div class="highlight">
<pre class="brush: js">

	/*
		text = text.replace(/
			^(\#{1,6})				// $1 = string of #'s
			[ \t]*
			(.+?)					// $2 = Header text
			[ \t]*
			\#*						// optional closing #'s (not counted)
			\n+
		/gm, function() {...});
	*/

	text = text.replace(/^(\#{1,6})[ \t]*(.+?)[ \t]*\#*\n+/gm,
		function(wholeMatch,m1,m2) {
			var h_level = m1.length;
			return hashBlock(&quot;&lt;h&quot; + h_level + ' id=&quot;' + headerId(m2) + '&quot;&gt;' + _RunSpanGamut(m2) + &quot;&lt;/h&quot; + h_level + &quot;&gt;&quot;);
		});

	function headerId(m) {
		return m.replace(/[^\w]/g, '').toLowerCase();
	}
	return text;
}
</pre>
					</div>
									</td>
			</tr>
					<tr id="section-'61'">
				<td class="docs">
					<div class="pilwrap">
						<a class="pilcrow" href="#section-61">&#182;
						</a>
					</div>
<div class="doc">
 This declaration keeps Dojo compressor from outputting garbage:</div>
				</td>
				<td class="code">
										<div class="highlight">
<pre class="brush: js">
var _ProcessListItems;

var _DoLists = function(text) {</pre>
					</div>
									</td>
			</tr>
					<tr id="section-'62'">
				<td class="docs">
					<div class="pilwrap">
						<a class="pilcrow" href="#section-62">&#182;
						</a>
					</div>
<div class="doc">

 Form HTML ordered (numbered) and unordered (bulleted) lists.
</div>
				</td>
				<td class="code">
									</td>
			</tr>
					<tr id="section-'63'">
				<td class="docs">
					<div class="pilwrap">
						<a class="pilcrow" href="#section-63">&#182;
						</a>
					</div>
<div class="doc">
 attacklab: add sentinel to hack around khtml/safari bug:
 http://bugs.webkit.org/show_bug.cgi?id=11231</div>
				</td>
				<td class="code">
										<div class="highlight">
<pre class="brush: js">
	text += &quot;~0&quot;;
</pre>
					</div>
									</td>
			</tr>
					<tr id="section-'64'">
				<td class="docs">
					<div class="pilwrap">
						<a class="pilcrow" href="#section-64">&#182;
						</a>
					</div>
<div class="doc">
 Re-usable pattern to match any entirel ul or ol list:</div>
				</td>
				<td class="code">
										<div class="highlight">
<pre class="brush: js">

	/*
		var whole_list = /
		(									// $1 = whole list
			(								// $2
				[ ]{0,3}					// attacklab: g_tab_width - 1
				([*+-]|\d+[.])				// $3 = first list item marker
				[ \t]+
			)
			[^\r]+?
			(								// $4
				~0							// sentinel for workaround; should be $
			|
				\n{2,}
				(?=\S)
				(?!							// Negative lookahead for another list item marker
					[ \t]*
					(?:[*+-]|\d+[.])[ \t]+
				)
			)
		)/g
	*/
	var whole_list = /^(([ ]{0,3}([*+-]|\d+[.])[ \t]+)[^\r]+?(~0|\n{2,}(?=\S)(?![ \t]*(?:[*+-]|\d+[.])[ \t]+)))/gm;

	if (g_list_level) {
		text = text.replace(whole_list,function(wholeMatch,m1,m2) {
			var list = m1;
			var list_type = (m2.search(/[*+-]/g)&gt;-1) ? &quot;ul&quot; : &quot;ol&quot;;
</pre>
					</div>
									</td>
			</tr>
					<tr id="section-'65'">
				<td class="docs">
					<div class="pilwrap">
						<a class="pilcrow" href="#section-65">&#182;
						</a>
					</div>
<div class="doc">
 Turn double returns into triple returns, so that we can make a
 paragraph for the last item in a list, if necessary:</div>
				</td>
				<td class="code">
										<div class="highlight">
<pre class="brush: js">
			list = list.replace(/\n{2,}/g,&quot;\n\n\n&quot;);;
			var result = _ProcessListItems(list);
	</pre>
					</div>
									</td>
			</tr>
					<tr id="section-'66'">
				<td class="docs">
					<div class="pilwrap">
						<a class="pilcrow" href="#section-66">&#182;
						</a>
					</div>
<div class="doc">
 Trim any trailing whitespace, to put the closing `</$list_type>`
 up on the preceding line, to get it past the current stupid
 HTML block parser. This is a hack to work around the terrible
 hack that is the HTML block parser.</div>
				</td>
				<td class="code">
										<div class="highlight">
<pre class="brush: js">
			result = result.replace(/\s+$/,&quot;&quot;);
			result = &quot;&lt;&quot;+list_type+&quot;&gt;&quot; + result + &quot;&lt;/&quot;+list_type+&quot;&gt;\n&quot;;
			return result;
		});
	} else {
		whole_list = /(\n\n|^\n?)(([ ]{0,3}([*+-]|\d+[.])[ \t]+)[^\r]+?(~0|\n{2,}(?=\S)(?![ \t]*(?:[*+-]|\d+[.])[ \t]+)))/g;
		text = text.replace(whole_list,function(wholeMatch,m1,m2,m3) {
			var runup = m1;
			var list = m2;

			var list_type = (m3.search(/[*+-]/g)&gt;-1) ? &quot;ul&quot; : &quot;ol&quot;;</pre>
					</div>
									</td>
			</tr>
					<tr id="section-'67'">
				<td class="docs">
					<div class="pilwrap">
						<a class="pilcrow" href="#section-67">&#182;
						</a>
					</div>
<div class="doc">
 Turn double returns into triple returns, so that we can make a
 paragraph for the last item in a list, if necessary:</div>
				</td>
				<td class="code">
										<div class="highlight">
<pre class="brush: js">
			var list = list.replace(/\n{2,}/g,&quot;\n\n\n&quot;);;
			var result = _ProcessListItems(list);
			result = runup + &quot;&lt;&quot;+list_type+&quot;&gt;\n&quot; + result + &quot;&lt;/&quot;+list_type+&quot;&gt;\n&quot;;	
			return result;
		});
	}
</pre>
					</div>
									</td>
			</tr>
					<tr id="section-'68'">
				<td class="docs">
					<div class="pilwrap">
						<a class="pilcrow" href="#section-68">&#182;
						</a>
					</div>
<div class="doc">
 attacklab: strip sentinel</div>
				</td>
				<td class="code">
										<div class="highlight">
<pre class="brush: js">
	text = text.replace(/~0/,&quot;&quot;);

	return text;
}

_ProcessListItems = function(list_str) {</pre>
					</div>
									</td>
			</tr>
					<tr id="section-'69'">
				<td class="docs">
					<div class="pilwrap">
						<a class="pilcrow" href="#section-69">&#182;
						</a>
					</div>
<div class="doc">

  Process the contents of a single ordered or unordered list, splitting it
  into individual list items.

 The $g_list_level global keeps track of when we're inside a list.
 Each time we enter a list, we increment it; when we leave a list,
 we decrement. If it's zero, we're not in a list anymore.

 We do this because when we're not inside a list, we want to treat
 something like this:

    I recommend upgrading to version
    8. Oops, now this line is treated
    as a sub-list.

 As a single paragraph, despite the fact that the second line starts
 with a digit-period-space sequence.

 Whereas when we're inside a list (or sub-list), that line will be
 treated as the start of a sub-list. What a kludge, huh? This is
 an aspect of Markdown's syntax that's hard to parse perfectly
 without resorting to mind-reading. Perhaps the solution is to
 change the syntax rules such that sub-lists must start with a
 starting cardinal number; e.g. "1." or "a.".</div>
				</td>
				<td class="code">
										<div class="highlight">
<pre class="brush: js">

	g_list_level++;
</pre>
					</div>
									</td>
			</tr>
					<tr id="section-'70'">
				<td class="docs">
					<div class="pilwrap">
						<a class="pilcrow" href="#section-70">&#182;
						</a>
					</div>
<div class="doc">
 trim trailing blank lines:</div>
				</td>
				<td class="code">
										<div class="highlight">
<pre class="brush: js">
	list_str = list_str.replace(/\n{2,}$/,&quot;\n&quot;);
</pre>
					</div>
									</td>
			</tr>
					<tr id="section-'71'">
				<td class="docs">
					<div class="pilwrap">
						<a class="pilcrow" href="#section-71">&#182;
						</a>
					</div>
<div class="doc">
 attacklab: add sentinel to emulate \z</div>
				</td>
				<td class="code">
										<div class="highlight">
<pre class="brush: js">
	list_str += &quot;~0&quot;;

	/*
		list_str = list_str.replace(/
			(\n)?							// leading line = $1
			(^[ \t]*)						// leading whitespace = $2
			([*+-]|\d+[.]) [ \t]+			// list marker = $3
			([^\r]+?						// list item text   = $4
			(\n{1,2}))
			(?= \n* (~0 | \2 ([*+-]|\d+[.]) [ \t]+))
		/gm, function(){...});
	*/
	list_str = list_str.replace(/(\n)?(^[ \t]*)([*+-]|\d+[.])[ \t]+([^\r]+?(\n{1,2}))(?=\n*(~0|\2([*+-]|\d+[.])[ \t]+))/gm,
		function(wholeMatch,m1,m2,m3,m4){
			var item = m4;
			var leading_line = m1;
			var leading_space = m2;

			if (leading_line || (item.search(/\n{2,}/)&gt;-1)) {
				item = _RunBlockGamut(_Outdent(item));
			}
			else {</pre>
					</div>
									</td>
			</tr>
					<tr id="section-'72'">
				<td class="docs">
					<div class="pilwrap">
						<a class="pilcrow" href="#section-72">&#182;
						</a>
					</div>
<div class="doc">
 Recursion for sub-lists:</div>
				</td>
				<td class="code">
										<div class="highlight">
<pre class="brush: js">
				item = _DoLists(_Outdent(item));
				item = item.replace(/\n$/,&quot;&quot;); // chomp(item)
				item = _RunSpanGamut(item);
			}

			return  &quot;&lt;li&gt;&quot; + item + &quot;&lt;/li&gt;\n&quot;;
		}
	);
</pre>
					</div>
									</td>
			</tr>
					<tr id="section-'73'">
				<td class="docs">
					<div class="pilwrap">
						<a class="pilcrow" href="#section-73">&#182;
						</a>
					</div>
<div class="doc">
 attacklab: strip sentinel</div>
				</td>
				<td class="code">
										<div class="highlight">
<pre class="brush: js">
	list_str = list_str.replace(/~0/g,&quot;&quot;);

	g_list_level--;
	return list_str;
}


var _DoCodeBlocks = function(text) {</pre>
					</div>
									</td>
			</tr>
					<tr id="section-'74'">
				<td class="docs">
					<div class="pilwrap">
						<a class="pilcrow" href="#section-74">&#182;
						</a>
					</div>
<div class="doc">

  Process Markdown `<pre><code>` blocks.
  </div>
				</td>
				<td class="code">
										<div class="highlight">
<pre class="brush: js">

	/*
		text = text.replace(text,
			/(?:\n\n|^)
			(								// $1 = the code block -- one or more lines, starting with a space/tab
				(?:
					(?:[ ]{4}|\t)			// Lines must start with a tab or a tab-width of spaces - attacklab: g_tab_width
					.*\n+
				)+
			)
			(\n*[ ]{0,3}[^ \t\n]|(?=~0))	// attacklab: g_tab_width
		/g,function(){...});
	*/
</pre>
					</div>
									</td>
			</tr>
					<tr id="section-'75'">
				<td class="docs">
					<div class="pilwrap">
						<a class="pilcrow" href="#section-75">&#182;
						</a>
					</div>
<div class="doc">
 attacklab: sentinel workarounds for lack of \A and \Z, safari\khtml bug</div>
				</td>
				<td class="code">
										<div class="highlight">
<pre class="brush: js">
	text += &quot;~0&quot;;
	
	text = text.replace(/(?:\n\n|^)((?:(?:[ ]{4}|\t).*\n+)+)(\n*[ ]{0,3}[^ \t\n]|(?=~0))/g,
		function(wholeMatch,m1,m2) {
			var codeblock = m1;
			var nextChar = m2;
		
			codeblock = _EncodeCode( _Outdent(codeblock));
			codeblock = _Detab(codeblock);
			codeblock = codeblock.replace(/^\n+/g,&quot;&quot;); // trim leading newlines
			codeblock = codeblock.replace(/\n+$/g,&quot;&quot;); // trim trailing whitespace

			codeblock = &quot;&lt;pre&gt;&lt;code&gt;&quot; + codeblock + &quot;\n&lt;/code&gt;&lt;/pre&gt;&quot;;

			return hashBlock(codeblock) + nextChar;
		}
	);
</pre>
					</div>
									</td>
			</tr>
					<tr id="section-'76'">
				<td class="docs">
					<div class="pilwrap">
						<a class="pilcrow" href="#section-76">&#182;
						</a>
					</div>
<div class="doc">
 attacklab: strip sentinel</div>
				</td>
				<td class="code">
										<div class="highlight">
<pre class="brush: js">
	text = text.replace(/~0/,&quot;&quot;);

	return text;
}

var hashBlock = function(text) {
	text = text.replace(/(^\n+|\n+$)/g,&quot;&quot;);
	return &quot;\n\n~K&quot; + (g_html_blocks.push(text)-1) + &quot;K\n\n&quot;;
}


var _DoCodeSpans = function(text) {</pre>
					</div>
									</td>
			</tr>
					<tr id="section-'77'">
				<td class="docs">
					<div class="pilwrap">
						<a class="pilcrow" href="#section-77">&#182;
						</a>
					</div>
<div class="doc">

   *  Backtick quotes are used for <code></code> spans.
 
   *  You can use multiple backticks as the delimiters if you want to
	 include literal backticks in the code span. So, this input:
	 
		 Just type ``foo `bar` baz`` at the prompt.
	 
	   Will translate to:
	 
		 <p>Just type <code>foo `bar` baz</code> at the prompt.</p>
	 
	There's no arbitrary limit to the number of backticks you
	can use as delimters. If you need three consecutive backticks
	in your code, use four for delimiters, etc.

  *  You can use spaces to get literal backticks at the edges:
	 
		 ... type `` `bar` `` ...
	 
	   Turns to:
	 
		 ... type <code>`bar`</code> ...
</div>
				</td>
				<td class="code">
										<div class="highlight">
<pre class="brush: js">

	/*
		text = text.replace(/
			(^|[^\\])					// Character before opening ` can't be a backslash
			(`+)						// $2 = Opening run of `
			(							// $3 = The code block
				[^\r]*?
				[^`]					// attacklab: work around lack of lookbehind
			)
			\2							// Matching closer
			(?!`)
		/gm, function(){...});
	*/

	text = text.replace(/(^|[^\\])(`+)([^\r]*?[^`])\2(?!`)/gm,
		function(wholeMatch,m1,m2,m3,m4) {
			var c = m3;
			c = c.replace(/^([ \t]*)/g,&quot;&quot;);	// leading whitespace
			c = c.replace(/[ \t]*$/g,&quot;&quot;);	// trailing whitespace
			c = _EncodeCode(c);
			return m1+&quot;&lt;code&gt;&quot;+c+&quot;&lt;/code&gt;&quot;;
		});

	return text;
}


var _EncodeCode = function(text) {</pre>
					</div>
									</td>
			</tr>
					<tr id="section-'78'">
				<td class="docs">
					<div class="pilwrap">
						<a class="pilcrow" href="#section-78">&#182;
						</a>
					</div>
<div class="doc">

 Encode/escape certain characters inside Markdown code runs.
 The point is that in code, these characters are literals,
 and lose their special Markdown meanings.

 Encode all ampersands; HTML entities are not
 entities within a Markdown code span.</div>
				</td>
				<td class="code">
										<div class="highlight">
<pre class="brush: js">
	text = text.replace(/&amp;/g,&quot;&amp;amp;&quot;);
</pre>
					</div>
									</td>
			</tr>
					<tr id="section-'79'">
				<td class="docs">
					<div class="pilwrap">
						<a class="pilcrow" href="#section-79">&#182;
						</a>
					</div>
<div class="doc">
 Do the angle bracket song and dance:</div>
				</td>
				<td class="code">
										<div class="highlight">
<pre class="brush: js">
	text = text.replace(/&lt;/g,&quot;&amp;lt;&quot;);
	text = text.replace(/&gt;/g,&quot;&amp;gt;&quot;);
</pre>
					</div>
									</td>
			</tr>
					<tr id="section-'80'">
				<td class="docs">
					<div class="pilwrap">
						<a class="pilcrow" href="#section-80">&#182;
						</a>
					</div>
<div class="doc">
 Now, escape characters that are magic in Markdown:</div>
				</td>
				<td class="code">
										<div class="highlight">
<pre class="brush: js">
	text = escapeCharacters(text,&quot;\*_{}[]\\&quot;,false);
</pre>
					</div>
									</td>
			</tr>
					<tr id="section-'81'">
				<td class="docs">
					<div class="pilwrap">
						<a class="pilcrow" href="#section-81">&#182;
						</a>
					</div>
<div class="doc">
 jj the line above breaks this:
---</div>
				</td>
				<td class="code">
									</td>
			</tr>
					<tr id="section-'82'">
				<td class="docs">
					<div class="pilwrap">
						<a class="pilcrow" href="#section-82">&#182;
						</a>
					</div>
<div class="doc">
* Item</div>
				</td>
				<td class="code">
									</td>
			</tr>
					<tr id="section-'83'">
				<td class="docs">
					<div class="pilwrap">
						<a class="pilcrow" href="#section-83">&#182;
						</a>
					</div>
<div class="doc">
   1. Subitem</div>
				</td>
				<td class="code">
									</td>
			</tr>
					<tr id="section-'84'">
				<td class="docs">
					<div class="pilwrap">
						<a class="pilcrow" href="#section-84">&#182;
						</a>
					</div>
<div class="doc">
            special char: *
---</div>
				</td>
				<td class="code">
										<div class="highlight">
<pre class="brush: js">

	return text;
}


var _DoItalicsAndBold = function(text) {
</pre>
					</div>
									</td>
			</tr>
					<tr id="section-'85'">
				<td class="docs">
					<div class="pilwrap">
						<a class="pilcrow" href="#section-85">&#182;
						</a>
					</div>
<div class="doc">

MARK: Added word boundaries to prevent underscores in class names from being
italiczed.
</div>
				</td>
				<td class="code">
									</td>
			</tr>
					<tr id="section-'86'">
				<td class="docs">
					<div class="pilwrap">
						<a class="pilcrow" href="#section-86">&#182;
						</a>
					</div>
<div class="doc">
 <strong> must go first:</div>
				</td>
				<td class="code">
										<div class="highlight">
<pre class="brush: js">
	text = text.replace(/\b(\*\*|__)(?=\S)([^\r]*?\S[*_]*)\1\b/g,
		&quot;&lt;strong&gt;$2&lt;/strong&gt;&quot;);

	text = text.replace(/\b(\*|_)(?=\S)([^\r]*?\S)\1\b/g,
		&quot;&lt;em&gt;$2&lt;/em&gt;&quot;);

	return text;
}


var _DoBlockQuotes = function(text) {

	/*
		text = text.replace(/
		(								// Wrap whole match in $1
			(
				^[ \t]*&gt;[ \t]?			// '&gt;' at the start of a line
				.+\n					// rest of the first line
				(.+\n)*					// subsequent consecutive lines
				\n*						// blanks
			)+
		)
		/gm, function(){...});
	*/

	text = text.replace(/((^[ \t]*&gt;[ \t]?.+\n(.+\n)*\n*)+)/gm,
		function(wholeMatch,m1) {
			var bq = m1;
</pre>
					</div>
									</td>
			</tr>
					<tr id="section-'87'">
				<td class="docs">
					<div class="pilwrap">
						<a class="pilcrow" href="#section-87">&#182;
						</a>
					</div>
<div class="doc">
 attacklab: hack around Konqueror 3.5.4 bug:
 "----------bug".replace(/^-/g,"") == "bug"</div>
				</td>
				<td class="code">
										<div class="highlight">
<pre class="brush: js">

			bq = bq.replace(/^[ \t]*&gt;[ \t]?/gm,&quot;~0&quot;);	// trim one level of quoting
</pre>
					</div>
									</td>
			</tr>
					<tr id="section-'88'">
				<td class="docs">
					<div class="pilwrap">
						<a class="pilcrow" href="#section-88">&#182;
						</a>
					</div>
<div class="doc">
 attacklab: clean up hack</div>
				</td>
				<td class="code">
										<div class="highlight">
<pre class="brush: js">
			bq = bq.replace(/~0/g,&quot;&quot;);

			bq = bq.replace(/^[ \t]+$/gm,&quot;&quot;);		// trim whitespace-only lines
			bq = _RunBlockGamut(bq);				// recurse
			
			bq = bq.replace(/(^|\n)/g,&quot;$1  &quot;);</pre>
					</div>
									</td>
			</tr>
					<tr id="section-'89'">
				<td class="docs">
					<div class="pilwrap">
						<a class="pilcrow" href="#section-89">&#182;
						</a>
					</div>
<div class="doc">
 These leading spaces screw with <pre> content, so we need to fix that:</div>
				</td>
				<td class="code">
										<div class="highlight">
<pre class="brush: js">
			bq = bq.replace(
					/(\s*&lt;pre&gt;[^\r]+?&lt;\/pre&gt;)/gm,
				function(wholeMatch,m1) {
					var pre = m1;</pre>
					</div>
									</td>
			</tr>
					<tr id="section-'90'">
				<td class="docs">
					<div class="pilwrap">
						<a class="pilcrow" href="#section-90">&#182;
						</a>
					</div>
<div class="doc">
 attacklab: hack around Konqueror 3.5.4 bug:</div>
				</td>
				<td class="code">
										<div class="highlight">
<pre class="brush: js">
					pre = pre.replace(/^  /mg,&quot;~0&quot;);
					pre = pre.replace(/~0/g,&quot;&quot;);
					return pre;
				});
			
			return hashBlock(&quot;&lt;blockquote&gt;\n&quot; + bq + &quot;\n&lt;/blockquote&gt;&quot;);
		});
	return text;
}


var _FormParagraphs = function(text) {</pre>
					</div>
									</td>
			</tr>
					<tr id="section-'91'">
				<td class="docs">
					<div class="pilwrap">
						<a class="pilcrow" href="#section-91">&#182;
						</a>
					</div>
<div class="doc">

  Params:
    $text - string to process with html <p> tags
</div>
				</td>
				<td class="code">
									</td>
			</tr>
					<tr id="section-'92'">
				<td class="docs">
					<div class="pilwrap">
						<a class="pilcrow" href="#section-92">&#182;
						</a>
					</div>
<div class="doc">
 Strip leading and trailing lines:</div>
				</td>
				<td class="code">
										<div class="highlight">
<pre class="brush: js">
	text = text.replace(/^\n+/g,&quot;&quot;);
	text = text.replace(/\n+$/g,&quot;&quot;);

	var grafs = text.split(/\n{2,}/g);
	var grafsOut = new Array();
</pre>
					</div>
									</td>
			</tr>
					<tr id="section-'93'">
				<td class="docs">
					<div class="pilwrap">
						<a class="pilcrow" href="#section-93">&#182;
						</a>
					</div>
<div class="doc">

 Wrap <p> tags.
</div>
				</td>
				<td class="code">
										<div class="highlight">
<pre class="brush: js">
	var end = grafs.length;
	for (var i=0; i&lt;end; i++) {
		var str = grafs[i];
</pre>
					</div>
									</td>
			</tr>
					<tr id="section-'94'">
				<td class="docs">
					<div class="pilwrap">
						<a class="pilcrow" href="#section-94">&#182;
						</a>
					</div>
<div class="doc">
 if this is an HTML marker, copy it</div>
				</td>
				<td class="code">
										<div class="highlight">
<pre class="brush: js">
		if (str.search(/~K(\d+)K/g) &gt;= 0) {
			grafsOut.push(str);
		}
		else if (str.search(/\S/) &gt;= 0) {
			str = _RunSpanGamut(str);
			str = str.replace(/^([ \t]*)/g,&quot;&lt;p&gt;&quot;);
			str += &quot;&lt;/p&gt;&quot;
			grafsOut.push(str);
		}

	}
</pre>
					</div>
									</td>
			</tr>
					<tr id="section-'95'">
				<td class="docs">
					<div class="pilwrap">
						<a class="pilcrow" href="#section-95">&#182;
						</a>
					</div>
<div class="doc">

 Unhashify HTML blocks
</div>
				</td>
				<td class="code">
										<div class="highlight">
<pre class="brush: js">
	end = grafsOut.length;
	for (var i=0; i&lt;end; i++) {</pre>
					</div>
									</td>
			</tr>
					<tr id="section-'96'">
				<td class="docs">
					<div class="pilwrap">
						<a class="pilcrow" href="#section-96">&#182;
						</a>
					</div>
<div class="doc">
 if this is a marker for an html block...</div>
				</td>
				<td class="code">
										<div class="highlight">
<pre class="brush: js">
		while (grafsOut[i].search(/~K(\d+)K/) &gt;= 0) {
			var blockText = g_html_blocks[RegExp.$1];
			blockText = blockText.replace(/\$/g,&quot;$$$$&quot;); // Escape any dollar signs
			grafsOut[i] = grafsOut[i].replace(/~K\d+K/,blockText);
		}
	}

	return grafsOut.join(&quot;\n\n&quot;);
}


var _EncodeAmpsAndAngles = function(text) {</pre>
					</div>
									</td>
			</tr>
					<tr id="section-'97'">
				<td class="docs">
					<div class="pilwrap">
						<a class="pilcrow" href="#section-97">&#182;
						</a>
					</div>
<div class="doc">
 Smart processing for ampersands and angle brackets that need to be encoded.</div>
				</td>
				<td class="code">
									</td>
			</tr>
					<tr id="section-'98'">
				<td class="docs">
					<div class="pilwrap">
						<a class="pilcrow" href="#section-98">&#182;
						</a>
					</div>
<div class="doc">
 Ampersand-encoding based entirely on Nat Irons's Amputator MT plugin:
   http://bumppo.net/projects/amputator/</div>
				</td>
				<td class="code">
										<div class="highlight">
<pre class="brush: js">
	text = text.replace(/&amp;(?!#?[xX]?(?:[0-9a-fA-F]+|\w+);)/g,&quot;&amp;amp;&quot;);
	</pre>
					</div>
									</td>
			</tr>
					<tr id="section-'99'">
				<td class="docs">
					<div class="pilwrap">
						<a class="pilcrow" href="#section-99">&#182;
						</a>
					</div>
<div class="doc">
 Encode naked <'s</div>
				</td>
				<td class="code">
										<div class="highlight">
<pre class="brush: js">
	text = text.replace(/&lt;(?![a-z\/?\$!])/gi,&quot;&amp;lt;&quot;);
	
	return text;
}


var _EncodeBackslashEscapes = function(text) {</pre>
					</div>
									</td>
			</tr>
					<tr id="section-'100'">
				<td class="docs">
					<div class="pilwrap">
						<a class="pilcrow" href="#section-100">&#182;
						</a>
					</div>
<div class="doc">

   Parameter:  String.
   Returns:	The string, with after processing the following backslash
			   escape sequences.
</div>
				</td>
				<td class="code">
									</td>
			</tr>
					<tr id="section-'101'">
				<td class="docs">
					<div class="pilwrap">
						<a class="pilcrow" href="#section-101">&#182;
						</a>
					</div>
<div class="doc">
 attacklab: The polite way to do this is with the new
 escapeCharacters() function:

 	text = escapeCharacters(text,"\\",true);
 	text = escapeCharacters(text,"`*_{}[]()>#+-.!",true);

 ...but we're sidestepping its use of the (slow) RegExp constructor
 as an optimization for Firefox.  This function gets called a LOT.</div>
				</td>
				<td class="code">
										<div class="highlight">
<pre class="brush: js">

	text = text.replace(/\\(\\)/g,escapeCharacters_callback);
	text = text.replace(/\\([`*_{}\[\]()&gt;#+-.!])/g,escapeCharacters_callback);
	return text;
}


var _DoAutoLinks = function(text) {

	text = text.replace(/&lt;((https?|ftp|dict):[^'&quot;&gt;\s]+)&gt;/gi,&quot;&lt;a href=\&quot;$1\&quot;&gt;$1&lt;/a&gt;&quot;);
</pre>
					</div>
									</td>
			</tr>
					<tr id="section-'102'">
				<td class="docs">
					<div class="pilwrap">
						<a class="pilcrow" href="#section-102">&#182;
						</a>
					</div>
<div class="doc">
 Email addresses: <address@domain.foo></div>
				</td>
				<td class="code">
										<div class="highlight">
<pre class="brush: js">

	/*
		text = text.replace(/
			&lt;
			(?:mailto:)?
			(
				[-.\w]+
				\@
				[-a-z0-9]+(\.[-a-z0-9]+)*\.[a-z]+
			)
			&gt;
		/gi, _DoAutoLinks_callback());
	*/
	text = text.replace(/&lt;(?:mailto:)?([-.\w]+\@[-a-z0-9]+(\.[-a-z0-9]+)*\.[a-z]+)&gt;/gi,
		function(wholeMatch,m1) {
			return _EncodeEmailAddress( _UnescapeSpecialChars(m1) );
		}
	);

	return text;
}


var _EncodeEmailAddress = function(addr) {</pre>
					</div>
									</td>
			</tr>
					<tr id="section-'103'">
				<td class="docs">
					<div class="pilwrap">
						<a class="pilcrow" href="#section-103">&#182;
						</a>
					</div>
<div class="doc">

  Input: an email address, e.g. "foo@example.com"

  Output: the email address as a mailto link, with each character
	of the address encoded as either a decimal or hex entity, in
	the hopes of foiling most address harvesting spam bots. E.g.:

	<a href="&#x6D;&#97;&#105;&#108;&#x74;&#111;:&#102;&#111;&#111;&#64;&#101;
	   x&#x61;&#109;&#x70;&#108;&#x65;&#x2E;&#99;&#111;&#109;">&#102;&#111;&#111;
	   &#64;&#101;x&#x61;&#109;&#x70;&#108;&#x65;&#x2E;&#99;&#111;&#109;</a>

  Based on a filter by Matthew Wickline, posted to the BBEdit-Talk
  mailing list: <http://tinyurl.com/yu7ue>
</div>
				</td>
				<td class="code">
									</td>
			</tr>
					<tr id="section-'104'">
				<td class="docs">
					<div class="pilwrap">
						<a class="pilcrow" href="#section-104">&#182;
						</a>
					</div>
<div class="doc">
 attacklab: why can't javascript speak hex?</div>
				</td>
				<td class="code">
										<div class="highlight">
<pre class="brush: js">
	function char2hex(ch) {
		var hexDigits = '0123456789ABCDEF';
		var dec = ch.charCodeAt(0);
		return(hexDigits.charAt(dec&gt;&gt;4) + hexDigits.charAt(dec&amp;15));
	}

	var encode = [
		function(ch){return &quot;&amp;#&quot;+ch.charCodeAt(0)+&quot;;&quot;;},
		function(ch){return &quot;&amp;#x&quot;+char2hex(ch)+&quot;;&quot;;},
		function(ch){return ch;}
	];

	addr = &quot;mailto:&quot; + addr;

	addr = addr.replace(/./g, function(ch) {
		if (ch == &quot;@&quot;) {</pre>
					</div>
									</td>
			</tr>
					<tr id="section-'105'">
				<td class="docs">
					<div class="pilwrap">
						<a class="pilcrow" href="#section-105">&#182;
						</a>
					</div>
<div class="doc">
 this *must* be encoded. I insist.</div>
				</td>
				<td class="code">
										<div class="highlight">
<pre class="brush: js">
			ch = encode[Math.floor(Math.random()*2)](ch);
		} else if (ch !=&quot;:&quot;) {</pre>
					</div>
									</td>
			</tr>
					<tr id="section-'106'">
				<td class="docs">
					<div class="pilwrap">
						<a class="pilcrow" href="#section-106">&#182;
						</a>
					</div>
<div class="doc">
 leave ':' alone (to spot mailto: later)</div>
				</td>
				<td class="code">
										<div class="highlight">
<pre class="brush: js">
			var r = Math.random();</pre>
					</div>
									</td>
			</tr>
					<tr id="section-'107'">
				<td class="docs">
					<div class="pilwrap">
						<a class="pilcrow" href="#section-107">&#182;
						</a>
					</div>
<div class="doc">
 roughly 10% raw, 45% hex, 45% dec</div>
				</td>
				<td class="code">
										<div class="highlight">
<pre class="brush: js">
			ch =  (
					r &gt; .9  ?	encode[2](ch)   :
					r &gt; .45 ?	encode[1](ch)   :
								encode[0](ch)
				);
		}
		return ch;
	});

	addr = &quot;&lt;a href=\&quot;&quot; + addr + &quot;\&quot;&gt;&quot; + addr + &quot;&lt;/a&gt;&quot;;
	addr = addr.replace(/&quot;&gt;.+:/g,&quot;\&quot;&gt;&quot;); // strip the mailto: from the visible part

	return addr;
}


var _UnescapeSpecialChars = function(text) {</pre>
					</div>
									</td>
			</tr>
					<tr id="section-'108'">
				<td class="docs">
					<div class="pilwrap">
						<a class="pilcrow" href="#section-108">&#182;
						</a>
					</div>
<div class="doc">

 Swap back in all the special characters we've hidden.
</div>
				</td>
				<td class="code">
										<div class="highlight">
<pre class="brush: js">
	text = text.replace(/~E(\d+)E/g,
		function(wholeMatch,m1) {
			var charCodeToReplace = parseInt(m1);
			return String.fromCharCode(charCodeToReplace);
		}
	);
	return text;
}


var _Outdent = function(text) {</pre>
					</div>
									</td>
			</tr>
					<tr id="section-'109'">
				<td class="docs">
					<div class="pilwrap">
						<a class="pilcrow" href="#section-109">&#182;
						</a>
					</div>
<div class="doc">

 Remove one level of line-leading tabs or spaces
</div>
				</td>
				<td class="code">
									</td>
			</tr>
					<tr id="section-'110'">
				<td class="docs">
					<div class="pilwrap">
						<a class="pilcrow" href="#section-110">&#182;
						</a>
					</div>
<div class="doc">
 attacklab: hack around Konqueror 3.5.4 bug:
 "----------bug".replace(/^-/g,"") == "bug"</div>
				</td>
				<td class="code">
										<div class="highlight">
<pre class="brush: js">

	text = text.replace(/^(\t|[ ]{1,4})/gm,&quot;~0&quot;); // attacklab: g_tab_width
</pre>
					</div>
									</td>
			</tr>
					<tr id="section-'111'">
				<td class="docs">
					<div class="pilwrap">
						<a class="pilcrow" href="#section-111">&#182;
						</a>
					</div>
<div class="doc">
 attacklab: clean up hack</div>
				</td>
				<td class="code">
										<div class="highlight">
<pre class="brush: js">
	text = text.replace(/~0/g,&quot;&quot;)

	return text;
}

var _Detab = function(text) {</pre>
					</div>
									</td>
			</tr>
					<tr id="section-'112'">
				<td class="docs">
					<div class="pilwrap">
						<a class="pilcrow" href="#section-112">&#182;
						</a>
					</div>
<div class="doc">
 attacklab: Detab's completely rewritten for speed.
 In perl we could fix it by anchoring the regexp with \G.
 In javascript we're less fortunate.</div>
				</td>
				<td class="code">
									</td>
			</tr>
					<tr id="section-'113'">
				<td class="docs">
					<div class="pilwrap">
						<a class="pilcrow" href="#section-113">&#182;
						</a>
					</div>
<div class="doc">
 expand first n-1 tabs</div>
				</td>
				<td class="code">
										<div class="highlight">
<pre class="brush: js">
	text = text.replace(/\t(?=\t)/g,&quot;    &quot;); // attacklab: g_tab_width
</pre>
					</div>
									</td>
			</tr>
					<tr id="section-'114'">
				<td class="docs">
					<div class="pilwrap">
						<a class="pilcrow" href="#section-114">&#182;
						</a>
					</div>
<div class="doc">
 replace the nth with two sentinels</div>
				</td>
				<td class="code">
										<div class="highlight">
<pre class="brush: js">
	text = text.replace(/\t/g,&quot;~A~B&quot;);
</pre>
					</div>
									</td>
			</tr>
					<tr id="section-'115'">
				<td class="docs">
					<div class="pilwrap">
						<a class="pilcrow" href="#section-115">&#182;
						</a>
					</div>
<div class="doc">
 use the sentinel to anchor our regex so it doesn't explode</div>
				</td>
				<td class="code">
										<div class="highlight">
<pre class="brush: js">
	text = text.replace(/~B(.+?)~A/g,
		function(wholeMatch,m1,m2) {
			var leadingText = m1;
			var numSpaces = 4 - leadingText.length % 4;  // attacklab: g_tab_width
</pre>
					</div>
									</td>
			</tr>
					<tr id="section-'116'">
				<td class="docs">
					<div class="pilwrap">
						<a class="pilcrow" href="#section-116">&#182;
						</a>
					</div>
<div class="doc">
 there *must* be a better way to do this:</div>
				</td>
				<td class="code">
										<div class="highlight">
<pre class="brush: js">
			for (var i=0; i&lt;numSpaces; i++) leadingText+=&quot; &quot;;

			return leadingText;
		}
	);
</pre>
					</div>
									</td>
			</tr>
					<tr id="section-'117'">
				<td class="docs">
					<div class="pilwrap">
						<a class="pilcrow" href="#section-117">&#182;
						</a>
					</div>
<div class="doc">
 clean up sentinels</div>
				</td>
				<td class="code">
										<div class="highlight">
<pre class="brush: js">
	text = text.replace(/~A/g,&quot;    &quot;);  // attacklab: g_tab_width
	text = text.replace(/~B/g,&quot;&quot;);

	return text;
}

</pre>
					</div>
									</td>
			</tr>
					<tr id="section-'118'">
				<td class="docs">
					<div class="pilwrap">
						<a class="pilcrow" href="#section-118">&#182;
						</a>
					</div>
<div class="doc">

  attacklab: Utility functions
</div>
				</td>
				<td class="code">
										<div class="highlight">
<pre class="brush: js">


var escapeCharacters = function(text, charsToEscape, afterBackslash) {</pre>
					</div>
									</td>
			</tr>
					<tr id="section-'119'">
				<td class="docs">
					<div class="pilwrap">
						<a class="pilcrow" href="#section-119">&#182;
						</a>
					</div>
<div class="doc">
 First we have to escape the escape characters so that
 we can build a character class out of them</div>
				</td>
				<td class="code">
										<div class="highlight">
<pre class="brush: js">
	var regexString = &quot;([&quot; + charsToEscape.replace(/([\[\]\\])/g,&quot;\\$1&quot;) + &quot;])&quot;;

	if (afterBackslash) {
		regexString = &quot;\\\\&quot; + regexString;
	}

	var regex = new RegExp(regexString,&quot;g&quot;);
	text = text.replace(regex,escapeCharacters_callback);

	return text;
}


var escapeCharacters_callback = function(wholeMatch,m1) {
	var charCodeToEscape = m1.charCodeAt(0);
	return &quot;~E&quot;+charCodeToEscape+&quot;E&quot;;
}

} // end of Showdown.converter
</pre>
					</div>
									</td>
			</tr>
					<tr id="section-'120'">
				<td class="docs">
					<div class="pilwrap">
						<a class="pilcrow" href="#section-120">&#182;
						</a>
					</div>
<div class="doc">
 export</div>
				</td>
				<td class="code">
										<div class="highlight">
<pre class="brush: js">
if (typeof exports != 'undefined') exports.Showdown = Showdown;</pre>
					</div>
									</td>
			</tr>
			</tbody>
</table>
		</div>
		<script src="http://code.jquery.com/jquery-1.7.1.min.js"></script>
<script src="http://markhuot.github.com/phocco/resources/showdown.js"></script>
<script>
	converter = new Showdown.converter();
	$(".doc").each(function() {
		$(this).html(converter.makeHtml($(this).text()));
	});

	$("#jump_handle").click(function(e){
		$("#jump_wrapper").toggle();
		e.preventDefault();
	});
</script>
<script src="https://raw.github.com/alexgorbatchev/SyntaxHighlighter/master/scripts/XRegExp.js"></script>
<script src="https://raw.github.com/alexgorbatchev/SyntaxHighlighter/master/scripts/shCore.js" type="text/javascript"></script>
<script src="http://alexgorbatchev.com/pub/sh/current/scripts/shAutoloader.js" type="text/javascript"></script>
<script type="text/javascript">
	function path()
	{
	  var args = arguments,
	      result = []
	      ;
	       
	  for(var i = 0; i < args.length; i++)
	      result.push(args[i].replace("@", "http://alexgorbatchev.com/pub/sh/current/scripts/"));
	       
	  return result
	};

	SyntaxHighlighter.autoloader.apply(null, path(
	  "applescript            @shBrushAppleScript.js",
	  "actionscript3 as3      @shBrushAS3.js",
	  "bash shell             @shBrushBash.js",
	  "coldfusion cf          @shBrushColdFusion.js",
	  "cpp c                  @shBrushCpp.js",
	  "c# c-sharp csharp      @shBrushCSharp.js",
	  "css                    @shBrushCss.js",
	  "delphi pascal          @shBrushDelphi.js",
	  "diff patch pas         @shBrushDiff.js",
	  "erl erlang             @shBrushErlang.js",
	  "groovy                 @shBrushGroovy.js",
	  "java                   @shBrushJava.js",
	  "jfx javafx             @shBrushJavaFX.js",
	  "js jscript javascript  @shBrushJScript.js",
	  "perl pl                @shBrushPerl.js",
	  "php                    @shBrushPhp.js",
	  "text plain             @shBrushPlain.js",
	  "py python              @shBrushPython.js",
	  "ruby rails ror rb      @shBrushRuby.js",
	  "sass scss              @shBrushSass.js",
	  "scala                  @shBrushScala.js",
	  "sql                    @shBrushSql.js",
	  "vb vbnet               @shBrushVb.js",
	  "xml xhtml xslt html    @shBrushXml.js"
	));
	SyntaxHighlighter.defaults["light"] = true;
	SyntaxHighlighter.defaults["unindent"] = false;
	SyntaxHighlighter.all();
</script>
	</body>
</html>
